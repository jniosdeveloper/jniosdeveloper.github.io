

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Cris">
  <meta name="keywords" content="iOS Web Android">
  
    <meta name="description" content="设计模式常用的7大原则 单一职责原则  单一职责原则规定一个类应该只有一个发生变化的原因。  接口隔离原则  客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上。  依赖倒转原则  高层模块不应该依赖低层模块，两者都应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。  里氏替换">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2022/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="J的前端博客馆">
<meta property="og:description" content="设计模式常用的7大原则 单一职责原则  单一职责原则规定一个类应该只有一个发生变化的原因。  接口隔离原则  客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上。  依赖倒转原则  高层模块不应该依赖低层模块，两者都应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。  里氏替换">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-23T15:06:10.000Z">
<meta property="article:modified_time" content="2022-12-23T15:06:57.435Z">
<meta property="article:author" content="Cris">
<meta property="article:tag" content="design pattern">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>设计模式 - J的前端博客馆</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":"enable","follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"QJxMK9qx93K6IfpxwDqMwyNE-gzGzoHsz","app_key":"vsGHGDbtAvIqTYMbJVVDmDa3","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>J的前端博客馆</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="设计模式"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-23 23:06" pubdate>
          2022年12月23日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          106 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="设计模式常用的7大原则"><a href="#设计模式常用的7大原则" class="headerlink" title="设计模式常用的7大原则"></a>设计模式常用的7大原则</h2><ul>
<li>单一职责原则</li>
</ul>
<p>单一职责原则规定一个类应该只有一个发生变化的原因。</p>
<ul>
<li>接口隔离原则</li>
</ul>
<p>客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上。</p>
<ul>
<li>依赖倒转原则</li>
</ul>
<p>高层模块不应该依赖低层模块，两者都应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<ul>
<li>里氏替换原则</li>
</ul>
<p>任何基类可以出现的地方，子类一定可以出现。子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<ul>
<li>开闭原则</li>
</ul>
<p>对扩展开放，对修改关闭。</p>
<ul>
<li>迪米特法则</li>
</ul>
<p>迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。</p>
<ul>
<li>合成复用原则</li>
</ul>
<p>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>用于描述怎样创建对象，它的主要特点是“将对象的创建与使用分离”。GOF中提供了单例、原型、工厂方法、抽象工厂、建造者等5种创建型模式。</p>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p>
<p>主要角色</p>
<ul>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品：实现或者继承抽象产品的子类。</li>
<li>具体工厂：提供了创建产品的方法，调用者通过该方法来创建产品。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码。如果要实现新产品直接修改工厂类，而不需要再原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”</li>
</ul>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>概念</p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品的实例化延迟到其工厂的子类。</p>
<p>结构</p>
<ul>
<li>抽象工厂（abstract factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（concreate  factory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（produce）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（concreate  produce）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li>
</ul>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无需指定所要产品的具体类就能得到同族不同等级的产品模式结构。</p>
<p>抽象工厂模式就是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>结构</p>
<ul>
<li>抽象工厂（abstract factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂(concreate factory)：主要是实现了抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品(product)：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品(concreate product)：实现了抽象产品所定义的接口，由具体工厂来创建，它同具体工厂是多对一的关系。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li>
</ul>
<p>缺点：</p>
<ul>
<li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li>
</ul>
<p>使用场景</p>
<ul>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢传某一个品牌的衣服和鞋。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ul>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>概述</p>
<p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>分离了部件的构造和装配。从而可以构建出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</p>
<p>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象，相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</p>
<p>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p>
<p>结构</p>
<ul>
<li>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的对象部件的创建。</li>
<li>具体建造者类（concreate builder）：实现builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</li>
<li>产品类（product）：要创建的复杂对象。</li>
<li>指挥者类（director）：调用具体建造者来创建复杂对象的各个部分，在指导中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li>
<li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>可以更加精细的控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险，符合开闭原则。</li>
</ul>
<p>缺点：</p>
<p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此使用范围受到一定的限制。</p>
<p>使用场景</p>
<p>建造者模式创建的是复杂对象，其产品的各个部分经常面临剧烈的变化，但将他们组合在一起的算法却相对稳定，所以它通常在以下场合使用:</p>
<ul>
<li>创建的对象复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>概述</p>
<p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>
<p>结构</p>
<ul>
<li>抽象原型类：规定了具体对象必须实现的clone方法。</li>
<li>具体原型类：实现抽象原型类中的clone方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的clone方法来复制新的对象。</li>
</ul>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>用于描述如何将类或对象按某种布局组成更大的结构。GOF书中提供了代理、适配性、桥接、装饰、外观、享元、组合等7种结构型模式。</p>
<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p>指在不改变现有对象结构的情况下，动态的给对象增加一些职责（即增加其额外功能）的模式。</p>
<p>主要角色</p>
<ul>
<li>抽象构建（component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构建（concreate component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（decorator）角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰角色（concreate decorator）：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理（proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（real subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提供了程序的可维护性。</p>
<p>外观模式是“迪米特法则”的典型应用。</p>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不符合开闭原则，修改很麻烦。</li>
</ul>
<p>使用场景</p>
<ul>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提供子系统的独立性和可移植性。</li>
</ul>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>定义</p>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对少些。</p>
<p>结构</p>
<ul>
<li>目标（target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<p>应用场景</p>
<ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>定义</p>
<p>又名部分整体模式，是用于把一组相似的对象当做一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<p>结构</p>
<ul>
<li>抽象根节点：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>
<li>树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>
<li>叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li>
<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无需对现有类库进行任何修改，符合”开闭原则“。</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li>
</ul>
<p>使用场景</p>
<ul>
<li>组合模式是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</li>
</ul>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>定义</p>
<p>运用共享技术来有效的支持大量细粒度对象的复用，它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<p>结构</p>
<p>享元模式中存在以下两种状态：</p>
<ol>
<li>内部状态，即不会随着环境的改变而改变的可共享部分。</li>
<li>外部状态，即随环境改变而改变的不可共享的部分，享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化，享元模式主要有以下角色：</li>
</ol>
<ul>
<li>抽象享元角色：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li>
<li>具体享元角色：它实现了抽象享元类，成为享元对象，在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li>
<li>非享元角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非具体享元类的对象时可以直接通过实例化创建。</li>
<li>享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户，如果不存在的话，则创建一个新的享元对象。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>极大减少内存中相似或相同对象数量，节约系统资源，提高系统性能。</li>
<li>享元模式中的外部状态相对独立，且不影响内部状态。</li>
</ul>
<p>缺点：</p>
<ul>
<li>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li>
<li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li>
</ul>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。Gof书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11种行为型模式。</p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>主要角色</p>
<ul>
<li>抽象策略类：此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境类（context）：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h4 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h4><p>定义</p>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤。</p>
<p>结构</p>
<p>主要角色</p>
<p>抽象类：</p>
<p>负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>
<ul>
<li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
</li>
<li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法可以分为三种：</p>
</li>
<li><ul>
<li>抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。</li>
<li>具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</li>
</ul>
</li>
</ul>
<p>具体子类：</p>
<p>实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>提高代码的复用性 - 将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</li>
<li>实现了反向控制 - 通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则”</li>
</ul>
<p>缺点：</p>
<ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一个反向的控制结构，它提高了代码阅读的难度。</li>
</ul>
<p>适用场景</p>
<ul>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>
</ul>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>概述</p>
<p>又称为发布-订阅模式，它定义了一种一对多的的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<p>结构</p>
<ul>
<li>subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>concreatesubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observe：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>concreteobserve：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li>
<li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃。</li>
</ul>
<p>使用场景</p>
<ul>
<li>对象存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模式有两个方面，其中一个方面依赖于另一方面时。</li>
</ul>
<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>定义</p>
<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链，当有请求发生时，可将    请求沿着这条链传递，直到有对象处理它为止。</p>
<p>结构</p>
<ul>
<li>抽象处理者角色：定义一个处理请求的接口，包含抽象处理方法和一个后继链接。</li>
<li>具体处理者角色：实现抽象处理者的处理方法，判断能否处理本次请求，如何可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类角色：创建处理链，并向链头的具体处理对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>降低了对象之间的耦合度 - 该模式降低了请求发送者和接受者的耦合度</li>
<li>增强了系统的可扩展性 - 可以根据需要增加新的请求处理类，满足开闭原则</li>
<li>增强了给对象指派职责的灵活性 - 当工作流程发生变化，可以动态地改变链内的成员或者修改他们的次序，也可动态地新增或者删除责任。</li>
<li>责任链简化了对象之间的连接 - 一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的if或者if else语句。</li>
<li>责任分担 - 每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个对象，系统性能将收到一定的影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ul>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>定义</p>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分开，这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
<p>结构</p>
<p>抽象命令类（command）角色：定义命令的接口，声明执行的方法。</p>
<p>具体命令（concreate command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来实现命令要执行的操作。</p>
<p>实现者、接收者（reciever）角色：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能实现命令要求实现的功能。</p>
<p>调用者 / 请求者（invoker）角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象，这个是客户端真正触发命令并要求执行相应操作的地方，也就是说相当于使用命令对象的入口。</p>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足”开闭原则“，对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现undo和redo操作，命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>系统结构更复杂。</li>
</ul>
<p>使用场景</p>
<ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销操作和恢复操作。</li>
</ul>
<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>定义</p>
<p>对有状态的对象，把复杂的”判断“逻辑提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p>结构</p>
<p>环境（context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</p>
<p>抽象状态（state）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</p>
<p>具体状态（concreate state）角色：实现抽象状态所对应的行为。</p>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合为一体，而不是某一个巨大的条件语句块。</li>
</ul>
<p>缺点：</p>
<ul>
<li>状态模式的使用必然会增加系统类的和对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当导致程序结构和代码的混乱。</li>
<li>状态模式对”开闭原则“的支持并不太好。</li>
</ul>
<p>使用场景</p>
<ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p>概述</p>
<p>备忘录提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态恢复，很多软件都提供了撤销undo操作，如word、记事本、等软件在编辑时按ctrl+Z组合键时能撤销当前操作，使文档恢复到之前的状态，还有在浏览器中的后退键、数据库事务管理的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能都属于这类。</p>
<p>定义</p>
<p>又叫做快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该软件之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p>
<p>结构</p>
<ul>
<li>发起人（originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<p>备忘录有俩个等效的接口：</p>
<ul>
<li>窄接口：管理者（caretaker）对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口（narror interface），这个窄接口只允许它把备忘录对象传给其他的对象。</li>
<li>宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口（wide interface），这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>提供了一种可以恢复状态的机制，当用户需要时能够比较方便的将数据恢复到某个历史的状态。</li>
<li>实现了内部的封装。除了创建它的发起人之外，其他对象都不能够访问这些历史状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个部分，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
</ul>
<p>使用场景</p>
<ul>
<li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li>
<li>需要提供一个可回滚操作的场景，如word、记事本、ps、idea等软件在编辑时按ctrl+z组合键，还有数据库中事务操作。</li>
</ul>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>概述</p>
<p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<p>结构</p>
<ul>
<li>抽象聚合（aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</li>
<li>具体聚合（concreate aggregate）角色：实现抽象聚合类，返回一个具体迭代器的实力</li>
<li>抽象迭代器（interator）角色：定义访问和遍历聚合元素的接口，通常包含hasNext（）、next（）等方法</li>
<li>具体迭代器（concreate interator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象，在同一聚合对象上可以定义多种遍历方式。在迭代器模式中需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li>
<li>迭代器简化了聚合类，由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li>
<li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足”开闭原则”的要求</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了类的个数，这在一定程序上增加了系统的复杂性。</li>
</ul>
<p>使用场景</p>
<ul>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无需暴露其内部细节的表示时。</li>
</ul>
<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p>定义</p>
<p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p>
<p>结构</p>
<ul>
<li>抽象中介者（mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li>具体中介者（concreate mediator）角色：实现中介者接口，定义一个list来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>
<li>抽象同事类（colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（concreate colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>
</ul>
<p>优缺点<br>优点：</p>
<ul>
<li>松散耦合 - 中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖，这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一而动全身”了。</li>
<li>集中控制交互 - 多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</li>
<li>一对多关联转变为一对一的关联 - 没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</li>
</ul>
<p>缺点：</p>
<ul>
<li>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</li>
</ul>
<p>使用场景</p>
<ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
</ul>
<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>定义</p>
<p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这个元素的新的操作。</p>
<p>结构</p>
<p>访问者模式包含以下主要角色：</p>
<ul>
<li><ul>
<li>抽象访问者（visitor）角色：定义了对每一个元素（element）访问的行为，它的参数就是可以访问的元素。他的方法个数理论上来讲与元素类个数是一样的，从这点不难看出，访问者模式要求元素的个数不能改变。</li>
</ul>
</li>
<li><p>具体访问者（concreate visitor）角色：给出对每一个元素类访问时所产生的具体行为。</p>
</li>
<li><p>抽象元素（element）角色：定义了一个接收访问者的方法（accept），其意义是指，每一个元素都要可以被访问者访问。</p>
</li>
<li><p>具体元素（concrete element）角色：提供接受访问方法的具体实现，而这个具体实现，通常情况下是使用访问者提供的访问该元素类的方法。</p>
</li>
<li><p>对象结构（object structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素，并且可以迭代这些元素，供访问者访问。</p>
</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>扩展性好 - 在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好 - 通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</li>
<li>分离无关行为 - 通过访问者来分离无关的行为，把相关的行为封装到一起，构成一个访问者，这样每一个访问者的功能都比较单一。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对象结构变化困难 - 在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了”开闭原则“。</li>
<li>违反了依赖倒置原则 - 访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ul>
<p>使用场景</p>
<ul>
<li>对象结构相对稳定，但其操作算法经常变化的程序。</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这个操作的变化影响对象的结构。</li>
</ul>
<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p>定义</p>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p>结构</p>
<p>解释器模式包含以下主要角色：</p>
<ul>
<li>抽象表达式（abstract expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法interpret（）。</li>
<li>终结符表达式（terminal expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（nonterminal expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条环境都对应于一个非终结符表达式。</li>
<li>环境角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li>客户端（client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ul>
<p>优缺点</p>
<p>优点：</p>
<ul>
<li>易于改变和扩展文法。- 由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法，每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</li>
<li>实现文法较为容易。 - 在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。</li>
<li>增加新的解释表达式较为方便。- 如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符符表达式类，原有表达式类代码无需修改，符合”开闭原则“。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于复杂文法难以维护。- 在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。</li>
<li>执行效率较低。- 由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</li>
</ul>
<p>使用场景</p>
<ul>
<li>当语言的文法较为简单，且执行效率不是关键问题时。</li>
<li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li>
<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/iOS/" class="category-chain-item">iOS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/design-pattern/">#design pattern</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>设计模式</div>
      <div>http://example.com/2022/12/23/设计模式/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Cris</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月23日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/23/%E5%A4%9A%E7%BA%A7%E8%81%94%E5%8A%A8%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="仿大众点评多级菜单实现">
                        <span class="hidden-mobile">仿大众点评多级菜单实现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"QJxMK9qx93K6IfpxwDqMwyNE-gzGzoHsz","appKey":"vsGHGDbtAvIqTYMbJVVDmDa3","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访客量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
